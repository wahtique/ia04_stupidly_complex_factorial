package agent;import behaviour.ParallelScheduler;import com.sun.org.apache.xpath.internal.operations.Bool;import jade.core.AID;import jade.core.Agent;import jade.core.behaviours.*;import jade.domain.DFService;import jade.domain.FIPAAgentManagement.DFAgentDescription;import jade.domain.FIPAAgentManagement.ServiceDescription;import jade.domain.FIPAException;import jade.lang.acl.ACLMessage;import jade.lang.acl.MessageTemplate;import javafx.beans.binding.When;import java.util.Random;public class FactAgent extends Agent{    ParallelScheduler OpScheduler;    public ParallelScheduler getOpScheduler()    {        return OpScheduler;    }    private AID searchServiceProvider(String serviceType, String serviceName)    {        DFAgentDescription template = new DFAgentDescription();        ServiceDescription sd = new ServiceDescription();        sd.setType(serviceType);        sd.setName(serviceName);        template.addServices(sd);        AID receiver = null;        try        {            DFAgentDescription[] result = DFService.search(this, template);            int n = result.length;            Random r = new Random();            if (n > 0)            {                int v = r.nextInt();                receiver = result[v].getName();            }        } catch (FIPAException e)        {            e.printStackTrace();        }        return null;    }    @Override    protected void setup()    {        System.out.println(getLocalName() + " Installed");        OpScheduler = new ParallelScheduler(this, ParallelBehaviour.WHEN_ALL);        addBehaviour(OpScheduler);        addBehaviour(new WaitForFactRequest());    }    private class WaitForFactRequest extends CyclicBehaviour    {        @Override        public void action()        {            MessageTemplate mt = MessageTemplate.MatchPerformative(ACLMessage.REQUEST);            ACLMessage msg = receive(mt);            if(msg != null)            {                //TODO add factrequest parsing and handling            }            else            {                block();            }        }    }    private class OutputBehaviour extends SequentialBehaviour    {        public OutputBehaviour(int N, long result, Boolean askMem)        {            super();            addSubBehaviour(new DisplayBehaviour(N,result));            if(askMem)            {                addSubBehaviour(new AskMemBehaviour(N,result));            }        }        private class DisplayBehaviour extends OneShotBehaviour        {            int N;            long result;            public DisplayBehaviour(int N, long result)            {              this. N = N;              this.result = result;            }            @Override            public void action()            {                System.out.println(N + "! = " + result);            }        }        private class AskMemBehaviour extends OneShotBehaviour        {            int N;            long result;            public AskMemBehaviour(int n, long result)            {                N = n;                this.result = result;            }            @Override            public void action()            {                AID receiver = searchServiceProvider("MEMORY", "MEMORIZE");                if(receiver != null)                {                    ACLMessage msg = new ACLMessage(ACLMessage.INFORM);                    msg.setContent(N + ";" + result);                    msg.addReceiver(receiver);                    send(msg);                }                else                {                    System.out.println("MEMORY NOT FOUND");                }            }        }    }    private class LookUpFactBehaviour extends SequentialBehaviour    {        AID receiver;        String convID;        int N;        long result;        public LookUpFactBehaviour(int n)        {            N = n;            convID = "LOOKUPFACT" + N + (new Random()).nextInt(666);            result = -1;        }        private class RequestMemLookUp extends OneShotBehaviour        {            int N;            AID receiver;            public RequestMemLookUp(int n, AID receiver)            {                N = n;                this.receiver = receiver;            }            @Override            public void action()            {                ACLMessage msg = new ACLMessage(ACLMessage.REQUEST);                msg.setContent(Integer.toString(N));                msg.setConversationId(convID);                msg.addReceiver(receiver);                send(msg);            }        }        private class WaitMemAnswer extends Behaviour        {            Boolean receivedMsg;            public WaitMemAnswer()            {                receivedMsg = false;            }            @Override            public void action()            {                MessageTemplate mt = MessageTemplate.and(MessageTemplate.MatchPerformative(ACLMessage.INFORM),MessageTemplate.MatchConversationId(convID));                ACLMessage msg = receive(mt);                if(msg != null)                {                    receivedMsg = true;                    if(msg.getContent().equalsIgnoreCase("nope"))                    {                        //TODO add factbehaviour qd on ne trouve pas d entree dans la memoire                    }                    else                    {                        String[] content = msg.getContent().split(";");                        //les messages doivnt etre de la forme "N;result"                        getOpScheduler().addSubBehaviour(new OutputBehaviour(Integer.parseInt(content[0]),Long.parseLong(content[1]),false));                    }                }                else                {                    block();                }            }            @Override            public boolean done()            {                return receivedMsg;            }        }    }    private class DoFactBehaviour extends SequentialBehaviour    {        int N;        long result;        String  convID;        AID receiver;        private class RequestMult extends OneShotBehaviour        {            long a;            long b;            public RequestMult(int a, int b)            {                this.a = a;                this.b = b;            }            @Override            public void action()            {                ACLMessage msg = new ACLMessage(ACLMessage.REQUEST);                msg.setConversationId(convID);                msg.addReceiver(receiver);                msg.setContent(a + "*" + b);                send(msg);            }        }        private class WaitForMultAnswer extends Behaviour        {            Boolean receivedMsg;            public WaitForMultAnswer()            {                receivedMsg = false;            }            @Override            public void action()            {                MessageTemplate mt = MessageTemplate.and(MessageTemplate.MatchPerformative(ACLMessage.INFORM),MessageTemplate.MatchConversationId(convID));                ACLMessage msg = receive(mt);                if(msg != null)                {                    result = Long.parseLong(msg.getContent());                    receivedMsg = true;                }                else                {                    block();                }            }            @Override            public boolean done()            {                return receivedMsg;            }        }        public DoFactBehaviour(int n)        {            N = n;            result = 1;            //TOD finish this        }    }}